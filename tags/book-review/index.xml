<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rubot</title>
    <link>https://rubot99.github.io/tags/book-review/index.xml</link>
    <description>Recent content on rubot</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://rubot99.github.io/tags/book-review/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Review - Refactoring - Improving the design of existing code - Part 2</title>
      <link>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-2/</link>
      <pubDate>Thu, 10 Aug 2017 21:30:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-2/</guid>
      <description>&lt;h3 id=&#34;chapter-2&#34;&gt;Chapter 2&lt;/h3&gt;

&lt;h3 id=&#34;goals-of-refactoring&#34;&gt;Goals of refactoring&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Refactoring code makes a code base easier to understand and modify.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Refactoring does not change observable the observable behaviour of the software.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;refactoring-improves-design&#34;&gt;Refactoring improves design&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Poorly designed code adds complexity and increase the number of lines of code required to achieve the same functionality. An important aspect of improving design is to eliminate duplicate code. Reducing the number of lines of code helps in future modification.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Code should easily communicate its purpose.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Refactoring helps achieve robust and scalable code&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Good design is vital for agile and fast software development. Teams can progress with a poorly designed code base for a period but eventually it catches up to the team and slows them down&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Refactoring should be done in short bursts instead of large chunks. Follow the boy scout rule and leave code that you have touched in a better state.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;refactoring-problem-areas&#34;&gt;Refactoring problem areas&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Databases are often difficult to refactor without causing major outages for a business or without writing extra code to work around refactored areas so to maintain existing behaviour.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poorly designed interfaces are difficult to change, since the team might not have access to all code bases that implement the interface.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Review - Refactoring - Improving the design of existing code - Part 1</title>
      <link>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-1/</link>
      <pubDate>Thu, 10 Aug 2017 20:30:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-1/</guid>
      <description>&lt;p&gt;Iâ€™m an avid listener of the CodingBlocks.Net podcasts and itâ€™s been one of my go to podcasts for software development. I have especially enjoyed the podcasts where the presenters reviewed the Clean Code book by having a podcast per chapter where they discussed their individual thoughts. So I thought I would follow their idea and write blogs posts reviewing Martin Fowlerâ€™s book on Refactoring. This year I wanted to read a few software development books and write a few posts, so what better way to merge my two goals reading the book and writing posts for the sections/chapters ðŸ˜‰&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;foreword-preface-chapter-1&#34;&gt;Foreword + Preface + Chapter 1&lt;/h3&gt;

&lt;p&gt;The first section talks about the importance of designing software before you start implementation. Good design is no substitute for immediate implementation gratification. Putting coding first is a sure way of spiralling from engineering to code hacking. Poor design reduces the readability and maintainability of your code. It is said code is read and modified more frequently than it is written. Poorly designed code bases often suffer from copy and paste code rather than reusable modules. This all makes code difficult to maintain and increasing the chances of adding bugs.&lt;/p&gt;

&lt;p&gt;Controlled refactoring is the way to improve an existing code base that might be poorly designed or one that has accumulated cruft over time. Refactoring is not a magic bullet but also has risks involved. Any modification to a code base has the potential to introduce bugs.&lt;/p&gt;

&lt;p&gt;One preliminary step you need to take before starting any refactoring is to have a comprehensive suite of tests. This ensures that existing functionality is not broken during the refactoring.&lt;/p&gt;

&lt;p&gt;The second step is to decompose things into smaller parts and to refactor. It is difficult to refactor large parts but is more manageable to refactor smaller parts.&lt;/p&gt;

&lt;p&gt;Renaming functions and variables are an important step. Good code should communicate its intent without the need of extra documentation. Readable code might initially seem less performant, but in the long run it will be easier to change.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Review - Test Driven Development by Example</title>
      <link>https://rubot99.github.io/2017/04/review---test-driven-development-by-example/</link>
      <pubDate>Mon, 10 Apr 2017 13:30:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/04/review---test-driven-development-by-example/</guid>
      <description>&lt;p&gt;Another of my new year resolutions is to read three computer science related books. So, the first book I choose was Kent Beckâ€™s book on TDD. I would say this book is the quintessential book on test driven development. I have owned this book for quite a few years but have never gotten around to reading it. So finally, I have taken plunge and have completed reading the book ðŸ˜Š.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;This book is under two hundred pages long and my initial impression was that it was an introductory style book for TDD. After reading the book, Iâ€™ve realised itâ€™s a lot more. The book is divided into three sections. The first section goes through the process of building new functionality into an existing software product using the TDD method. It takes you through all the steps and shows the pitfalls you might encounter. The main purpose of the scenario is to teach you the concepts with an example that will be easy to understand. It hammers home the importance of taking small test while writing new tests and writing enough code to make your tests pass. Following the write-run-refactor mantra is important and it also shows that taking bigger code steps might actually be counterproductive in the long run. I think as developers we are often too eager to sling code but the TDD process does force you to think before you leap. The second section goes through the process of setting you environment and testing framework. The third section I found very interesting, itâ€™s more of a reference section. I can see myself referring to that section a lot more in the future. It covers patterns and practices for TDD and refactoring and design patterns in general.&lt;/p&gt;

&lt;p&gt;After reading the book I appreciate the importance of taking smaller steps in code when doing TDD. I understand the reason behind writing enough code to make your test pass, since it prevents from over engineering your problem and falling into the YAGNI trap. Overall I think this book is good to help you get into the TDD mindset.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>