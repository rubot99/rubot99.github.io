<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rubot</title>
    <link>https://rubot99.github.io/tags/book-review/index.xml</link>
    <description>Recent content on rubot</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://rubot99.github.io/tags/book-review/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Review - The Phoenix Project</title>
      <link>https://rubot99.github.io/2017/09/review---the-phoenix-project/</link>
      <pubDate>Sun, 10 Sep 2017 17:30:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/09/review---the-phoenix-project/</guid>
      <description>&lt;p&gt;&lt;strong&gt;â€˜The Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Winâ€™&lt;/strong&gt; is a book about common situations you face working on software projects. The book teaches concepts and ideas through story form, it is very similar to books like the â€˜One minute managerâ€™ and â€˜The richest man in Babylonâ€™. Iâ€™ve read both these books and enjoyed how the simple truths and ideas are very cleverly conveyed through the story.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The book starts with a story of a fictitious company that is a market leader in their field, however in the last couple of years their competitors have been over taking them. The company has a new software project that will help them regain their pole position, but due to development issues they have been unable to deliver the product. In the book, we follow the acting CIO and problems he faces taking up this new role.&lt;/p&gt;

&lt;h3 id=&#34;the-first-part-of-the-book-discusses-issues&#34;&gt;The first part of the book discusses issues&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Lack of communication between development, infrastructure and testing&lt;/li&gt;
&lt;li&gt;Poor estimates for work&lt;/li&gt;
&lt;li&gt;Poor software processes&lt;/li&gt;
&lt;li&gt;No change request process or change authorisation process&lt;/li&gt;
&lt;li&gt;No priority for tasks and a lack of a complete task list&lt;/li&gt;
&lt;li&gt;Work politics - issues with Senior management and other teams&lt;/li&gt;
&lt;li&gt;The latest technology wonâ€™t fix process issues&lt;/li&gt;
&lt;li&gt;Caught in the cycle of delivering features without considering risks&lt;/li&gt;
&lt;li&gt;All tasks cannot have the highest priority&lt;/li&gt;
&lt;li&gt;Problem with always being in firefighting mode&lt;/li&gt;
&lt;li&gt;Different types of work i.e. Business projects, Internal projects, Change request and unplanned&lt;/li&gt;
&lt;li&gt;Unplanned work is the most destructive type of work, often considered anti-work&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;second-half-of-the-book-discusses-concepts-and-ideas&#34;&gt;Second half of the book discusses concepts and ideas&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;You can&amp;rsquo;t sort the strategic until you sort the tactical&lt;/li&gt;
&lt;li&gt;Having transparency is good but allowing generals access to every private can have a detrimental effect on the war effort.&lt;/li&gt;
&lt;li&gt;Having a proper and planned change request process is very important&lt;/li&gt;
&lt;li&gt;Implementing work tracking is important&lt;/li&gt;
&lt;li&gt;Finding your bottlenecks will help you have a steady flow of work and also planning work order and priority&lt;/li&gt;
&lt;li&gt;Outsource work but not responsibility&lt;/li&gt;
&lt;li&gt;IT is a core of the business not a cost centre&lt;/li&gt;
&lt;li&gt;Technical debt that is not paid down, compounds interest in the long run in the form on unplanned work&lt;/li&gt;
&lt;li&gt;Reduced deployment times helps increase the number of deployments&lt;/li&gt;
&lt;li&gt;Removing human interventions during deployment ensure that we can consistency reproduce deployments&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-book-concludes-with-the-team-implementing&#34;&gt;The book concludes with the team implementing&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Planned and approved change request process&lt;/li&gt;
&lt;li&gt;Implementation of Agile and Kanban&lt;/li&gt;
&lt;li&gt;Increased communication and transparency between teams&lt;/li&gt;
&lt;li&gt;Removal of knowledge bottlenecks through knowledge based systems&lt;/li&gt;
&lt;li&gt;Automated deployments&lt;/li&gt;
&lt;li&gt;Move to cloud based systems&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Review - Art of Discarding</title>
      <link>https://rubot99.github.io/2017/08/review---art-of-discarding/</link>
      <pubDate>Thu, 31 Aug 2017 17:30:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/08/review---art-of-discarding/</guid>
      <description>&lt;p&gt;The art of discarding is about mainly changing our mind set so that we have a positive attitude towards discarding items that we donâ€™t use. The book goes through attitudes and strategies to discard items by giving different scenarios and how to overcome them.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The first part of the book discusses the Japanese concept of Mottani, which the shame associated with wastefulness. In the past things were precious people looked after and used their possessions. Often after an item lost itâ€™s purpose, people tended to find new ways of re-purposing itâ€™s purpose.
However today there has been a switch from an era were things were precious to a point where everything is in abundance. With the market being flooded with new things, we have changed to view that new is always better. We are drowning in stuff because we are not buying possessions because we need them but because we want them. We are buying more stuff but because of our in grained view of Mottani, we are not discarding things as fast as we are buying them. We need a positive attitude to discarding, instead of thinking of discarding as wastefulness, we need to look at it as a way of assessing the value of things. We must not fall into the trap of thinking that not throwing something away is that same as looking after it. We need to remember that â€˜Keep things you use and discard things you donâ€™tâ€™. The best way to cherish something is to use it.&lt;/p&gt;

&lt;h3 id=&#34;attitudes-that-prevent-us-from-discarding&#34;&gt;Attitudes that prevent us from discarding&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Donâ€™t keep items for now - Discard it right away because you will end getting rid of things in the end&lt;/li&gt;
&lt;li&gt;Avoid temporary storage because those places tend to become permanent&lt;/li&gt;
&lt;li&gt;Some time never comes - items like clothes are kept because some time you could use it&lt;/li&gt;
&lt;li&gt;Buying things for convenience&lt;/li&gt;
&lt;li&gt;Nothing is sacred - If you own an item, you should use it, if you donâ€™t use it then donâ€™t have it.&lt;/li&gt;
&lt;li&gt;Storage and organisational methods are not the solution to discarding items&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;strategies-to-help-in-dicarding&#34;&gt;Strategies to help in dicarding&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;When something catches your attention ask your self can you get rid of it.&lt;/li&gt;
&lt;li&gt;Discard things as soon as you receive them - Don&amp;rsquo;t keep them to discard later&lt;/li&gt;
&lt;li&gt;Give away things you donâ€™t need to someone who will want and appreciate it&lt;/li&gt;
&lt;li&gt;When you have excess of a certain item, get rid of it&lt;/li&gt;
&lt;li&gt;Discard items when you have not used them after a period of time&lt;/li&gt;
&lt;li&gt;Limit the space you have for items&lt;/li&gt;
&lt;li&gt;If you have not completely used something get rid of it&lt;/li&gt;
&lt;li&gt;Set criteria for disposal and do not give any item special exemptions&lt;/li&gt;
&lt;li&gt;Assign responsibility for disposal of an area or items to particular person&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Review - Refactoring - Improving the design of existing code - Part 3</title>
      <link>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-3/</link>
      <pubDate>Sat, 12 Aug 2017 21:00:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-3/</guid>
      <description>&lt;h3 id=&#34;chapter-3&#34;&gt;Chapter 3&lt;/h3&gt;

&lt;p&gt;This chapter is all about various code smells and how we can try to identify them.
The first code smell is duplicated code. Duplicated code means more places to make code changes and higher risks of bugs being added. The best way to fix this issue is to either extract the code into a new method or into a different class.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Switch statements are another code smell. Switch statements often have a lot of duplicated code. Use polymorphism to replace switch statements.
Long methods are another code smell. Long methods make it difficult to understand the purpose of the code. Long methods always end up doing more than one thing, methods should have one responsibility (SRP). This makes it easier to understand the code and modify in the future. Good naming of methods helps a reader understand the purpose of the method. Modern languages have eliminated the overhead of in process calls, allowing smaller methods without effecting performance. Another good rule of thumb is that blocks of code that need comments are ideal candidates for decomposing into smaller methods. Large classes should also be decomposed into sub classes or extracted into other classes. Methods with long parameter lists should be reduced for readability by using objects instead.
So far we have mentioned splitting classes and methods, but sometimes you will need to merge classes and methods. This will help to bring methods that have similar purposes to be together, making it easier to modify and understand.
If there are classes that only pass information from one class to a client, then it might be worth removing the middleman class. Remove unwanted abstraction that is not required. Temporary fields are also another form of code smell and make code to be difficult to debug and modify. Data model class might be considered also as code smells. Poor inheritance is a code smell this is where class inherits behaviours from a super class that it does not require. Classes that overly use another classes private methods and variable is a break of the encapsulation rule. Finally comments can be a code smell, instead of simplifying complex code the use of comments is a way to allow the reader to understand it better. Often code is modified but the comments arenâ€™t which will causes further complications for the reader.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Review - Refactoring - Improving the design of existing code - Part 2</title>
      <link>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-2/</link>
      <pubDate>Thu, 10 Aug 2017 21:30:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-2/</guid>
      <description>&lt;h3 id=&#34;chapter-2&#34;&gt;Chapter 2&lt;/h3&gt;

&lt;h3 id=&#34;goals-of-refactoring&#34;&gt;Goals of refactoring&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Refactoring code makes a code base easier to understand and modify.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Refactoring does not change observable the observable behaviour of the software.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;refactoring-improves-design&#34;&gt;Refactoring improves design&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Poorly designed code adds complexity and increase the number of lines of code required to achieve the same functionality. An important aspect of improving design is to eliminate duplicate code. Reducing the number of lines of code helps in future modification.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Code should easily communicate its purpose.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Refactoring helps achieve robust and scalable code&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Good design is vital for agile and fast software development. Teams can progress with a poorly designed code base for a period but eventually it catches up to the team and slows them down&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Refactoring should be done in short bursts instead of large chunks. Follow the boy scout rule and leave code that you have touched in a better state.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;refactoring-problem-areas&#34;&gt;Refactoring problem areas&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Databases are often difficult to refactor without causing major outages for a business or without writing extra code to work around refactored areas so to maintain existing behaviour.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poorly designed interfaces are difficult to change, since the team might not have access to all code bases that implement the interface.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Review - Refactoring - Improving the design of existing code - Part 1</title>
      <link>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-1/</link>
      <pubDate>Thu, 10 Aug 2017 20:30:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/08/review---refactoring---improving-the-design-of-existing-code---part-1/</guid>
      <description>&lt;p&gt;Iâ€™m an avid listener of the CodingBlocks.Net podcasts and itâ€™s been one of my go to podcasts for software development. I have especially enjoyed the podcasts where the presenters reviewed the Clean Code book by having a podcast per chapter where they discussed their individual thoughts. So I thought I would follow their idea and write blogs posts reviewing Martin Fowlerâ€™s book on Refactoring. This year I wanted to read a few software development books and write a few posts, so what better way to merge my two goals reading the book and writing posts for the sections/chapters ðŸ˜‰&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;foreword-preface-chapter-1&#34;&gt;Foreword + Preface + Chapter 1&lt;/h3&gt;

&lt;p&gt;The first section talks about the importance of designing software before you start implementation. Good design is no substitute for immediate implementation gratification. Putting coding first is a sure way of spiralling from engineering to code hacking. Poor design reduces the readability and maintainability of your code. It is said code is read and modified more frequently than it is written. Poorly designed code bases often suffer from copy and paste code rather than reusable modules. This all makes code difficult to maintain and increasing the chances of adding bugs.&lt;/p&gt;

&lt;p&gt;Controlled refactoring is the way to improve an existing code base that might be poorly designed or one that has accumulated cruft over time. Refactoring is not a magic bullet but also has risks involved. Any modification to a code base has the potential to introduce bugs.&lt;/p&gt;

&lt;p&gt;One preliminary step you need to take before starting any refactoring is to have a comprehensive suite of tests. This ensures that existing functionality is not broken during the refactoring.&lt;/p&gt;

&lt;p&gt;The second step is to decompose things into smaller parts and to refactor. It is difficult to refactor large parts but is more manageable to refactor smaller parts.&lt;/p&gt;

&lt;p&gt;Renaming functions and variables are an important step. Good code should communicate its intent without the need of extra documentation. Readable code might initially seem less performant, but in the long run it will be easier to change.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Review - Test Driven Development by Example</title>
      <link>https://rubot99.github.io/2017/04/review---test-driven-development-by-example/</link>
      <pubDate>Mon, 10 Apr 2017 13:30:00 +0000</pubDate>
      
      <guid>https://rubot99.github.io/2017/04/review---test-driven-development-by-example/</guid>
      <description>&lt;p&gt;Another of my new year resolutions is to read three computer science related books. So, the first book I choose was Kent Beckâ€™s book on TDD. I would say this book is the quintessential book on test driven development. I have owned this book for quite a few years but have never gotten around to reading it. So finally, I have taken plunge and have completed reading the book ðŸ˜Š.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;This book is under two hundred pages long and my initial impression was that it was an introductory style book for TDD. After reading the book, Iâ€™ve realised itâ€™s a lot more. The book is divided into three sections. The first section goes through the process of building new functionality into an existing software product using the TDD method. It takes you through all the steps and shows the pitfalls you might encounter. The main purpose of the scenario is to teach you the concepts with an example that will be easy to understand. It hammers home the importance of taking small test while writing new tests and writing enough code to make your tests pass. Following the write-run-refactor mantra is important and it also shows that taking bigger code steps might actually be counterproductive in the long run. I think as developers we are often too eager to sling code but the TDD process does force you to think before you leap. The second section goes through the process of setting you environment and testing framework. The third section I found very interesting, itâ€™s more of a reference section. I can see myself referring to that section a lot more in the future. It covers patterns and practices for TDD and refactoring and design patterns in general.&lt;/p&gt;

&lt;p&gt;After reading the book I appreciate the importance of taking smaller steps in code when doing TDD. I understand the reason behind writing enough code to make your test pass, since it prevents from over engineering your problem and falling into the YAGNI trap. Overall I think this book is good to help you get into the TDD mindset.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>